<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="data:image/svg+xml,
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
<text y='.9em' font-size='90'>üïπÔ∏è</text>
</svg>">

  <meta charset="UTF-8" />
  <title>Week 09 ‚Äì Space Shooter Pt. 1 | Game Dev With Rob</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- RaRa theme CSS -->
  <link rel="stylesheet" href="assets/rara-games-devtools.css" />

  <!-- Prism.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body>

  <!-- Top site header -->
  <header class="site-header">
    <div class="header-inner">
      <div class="brand">
        <div class="brand-main">
          <div class="brand-dot"></div>
          <span>Game Dev With Rob üïπÔ∏è</span>
        </div>
        <div class="brand-course">
          <!-- MODULE CODE + TITLE HERE -->
          GDD422 ‚Äì Prototypes &amp; Programming Principles
        </div>
      </div>
    </div>
  </header>

  <main class="lecture-page">

    <!-- LECTURE HEADER (now static, not sticky) -->
    <header class="lecture-header">
      <h1><!-- LECTURE TITLE HERE -->Space Shooter Pt. 1</h1>

      <div class="lecture-meta-line">
        <!-- MODULE TITLE + WEEK INFO HERE -->
        GDD422 ‚Äì Week 09
      </div>

      <div class="tags">
        <!-- TAGS / TOPICS HERE -->
        <span class="tag">C#</span>
        <span class="tag">Lab</span>
        <span class="tag">2D Arcade</span>
      </div>

      <p class="lecture-aim">
        <!-- AIM TEXT HERE -->
        Aim: Start building a fun and frantic arcade-style shmup in Unity C#.
      </p>
    </header>

    <hr />

 <!-- GAMMA EMBED BLOCK -->
<section class="lecture-section" id="slides">
  <h2>Lecture Slides</h2>

  <!-- FULLSCREEN TOGGLE BUTTON -->
  <button id="fullscreenBtn" class="resource-pill" style="margin-bottom: 1rem;">
    ‚õ∂ Fullscreen Slides
  </button>

  <!-- EMBED WRAPPER -->
  <div class="gamma-embed">
    <div class="gamma-embed-inner">

      <iframe
        id="gammaFrame"
        src="https://gamma.app/embed/e842znwz41ztvgw"
        loading="lazy"
        allowfullscreen
        allow="fullscreen"
        style="border: 0;"
      ></iframe>

    </div>
  </div>
</section>

<!-- FULLSCREEN JS -->
<script>
  const iframe = document.getElementById('gammaFrame');
  const btn = document.getElementById('fullscreenBtn');

  btn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      iframe.requestFullscreen().then(() => {
        btn.textContent = "‚õ∂ Exit Fullscreen";
      }).catch(err => {
        console.error("Fullscreen error: ", err);
      });
    } else {
      document.exitFullscreen().then(() => {
        btn.textContent = "‚õ∂ Fullscreen Slides";
      });
    }
  });

  // Ensure the button resets if user exits with ESC or browser UI
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      btn.textContent = "‚õ∂ Fullscreen Slides";
    }
  });
</script>



    <hr />

    <!-- APPENDICES / CODE EXAMPLES -->
    <section class="lecture-section appendix-section" id="appendices">
      <h2>Appendices / Code Examples</h2>

      <!-- CODE BLOCK 1 -->
      <article class="code-example" id="code-block-1">
        <div class="code-header">
          <div class="code-title">Code Block 1 ‚Äì <!-- Short description here -->Player Movement</div>
          <div class="code-ref">Appendix #01</div>
        </div>
<details>
<summary>üí° Hints (click to expand)</summary>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;

public class Player : MonoBehaviour
{
    [Header("Movement")]
    public float moveSpeed = 5f;

    void Update()
    {
        HandleMovement();
    }

    private void HandleMovement()
    {
        // Read input axes
        float moveX = Input.GetAxis("Horizontal");
        float moveY = Input.GetAxis("Vertical");

        // 2D movement vector
        Vector3 movement = new Vector3(moveX, moveY, 0f) * moveSpeed * Time.deltaTime;

        // Proposed new position
        Vector3 newPos = transform.position + movement;

        // Apply
        transform.position = newPos;
    }
}

        </code></pre>
  </details>

        <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          Make sure you‚Äôre adding the movement onto the current position and using <code>deltaTime</code>, otherwise the player will move inconsistently or far too quickly.
        </blockquote>
      </article>
  
      <!-- CODE BLOCK 2 -->
      <article class="code-example" id="code-block-2">
        <div class="code-header">
          <div class="code-title">Code Block 2 ‚Äì <!-- Short description here -->Screen Boundaries.</div>
          <div class="code-ref">Appendix #02</div>
        </div>
<details>
<summary>üí° Hints (click to expand)</summary>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;

public class Player : MonoBehaviour
{
    [Header("Movement")] // Use can headers in you variables to make them pretty in the inspector
    public float moveSpeed = 8f;

    [Header("Screen Bounds")]
    public Camera cam; //The camera in our scene
    public float horizontalPadding = 0.55f; // How close can we get to the sides
    public float verticalPadding = 0.55f; // How close can we get to the sides
    private float minX, maxX; //Where we store the world edge x values
    private float minY, maxY; //Where we store the world edge y values

    void Start()
    {
        // Assign the main camera if not set
        if (cam == null)
        {
            cam = Camera.main;

            if (cam == null)
            {
                Debug.LogError("[Player] No Camera assigned and no MainCamera found.");
                enabled = false; // Disable script so that we dont spam errors or run broken logic
                return;
            }
        }

        CalculateScreenBounds();
    }


    void Update()
    {
        HandleMovement();
    }

    private void CalculateScreenBounds()
    {
        Vector3 leftEdge = cam.ViewportToWorldPoint(new Vector3(0f, 0.5f, 0f));
        Vector3 rightEdge = cam.ViewportToWorldPoint(new Vector3(1f, 0.5f, 0f));
        Vector3 topEdge = cam.ViewportToWorldPoint(new Vector3(0.5f, 1f, 0f));
        Vector3 bottomEdge = cam.ViewportToWorldPoint(new Vector3(0.5f, 0f, 0f));

        minX = leftEdge.x + horizontalPadding;
        maxX = rightEdge.x - horizontalPadding;
        minY = bottomEdge.y + verticalPadding;
        maxY = topEdge.y - verticalPadding;

        // Cleaner Log Messages - you can use $"Message text goes here {Variable1} and {Variable2)" in Debug.Log
        Debug.Log($"The screen bounds are minX: {minX}, maxX: {maxX}, minY: {minY} ,maxY: {maxY}");
    }

    private void HandleMovement()
    {
        // Read input axes
        float moveX = Input.GetAxis("Horizontal");
        float moveY = Input.GetAxis("Vertical");

        // 2D movement vector
        Vector3 movement = new Vector3(moveX, moveY, 0f) * moveSpeed * Time.deltaTime;

        // Proposed new position
        Vector3 newPos = transform.position + movement;

        // Clamp X and Y
        newPos.x = Mathf.Clamp(newPos.x, minX, maxX);
        newPos.y = Mathf.Clamp(newPos.y, minY, maxY);

        // Preserve current Z (important even in 2D)
        newPos.z = transform.position.z;

        // Apply
        transform.position = newPos;
    }

}

        </code></pre>
</details>

        <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If clamping doesn‚Äôt work, check that the camera is tagged ‚ÄúMainCamera‚Äù and that you calculated min/max using <code>ViewportToWorldPoint</code> with the correct coordinates.
        </blockquote>
      </article>
  

      <!-- CODE BLOCK 3 -->
      <article class="code-example" id="code-block-3">
        <div class="code-header">
          <div class="code-title">Code Block 3 ‚Äì <!-- Short description here -->Preliminary Laser Firing</div>
          <div class="code-ref">Appendix #03</div>
        </div>
        <details>
<summary>üí° Hints (click to expand)</summary>
<code>Player.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;

public class Player : MonoBehaviour
{
    [Header("Movement")] // Use can headers in you variables to make them pretty in the inspector
    public float moveSpeed = 8f;

    [Header("Screen Bounds")]
    public Camera cam; //The camera in our scene
    public float horizontalPadding = 0.55f; // How close can we get to the sides
    public float verticalPadding = 0.55f; // How close can we get to the sides
    private float minX, maxX; //Where we store the world edge x values
    private float minY, maxY; //Where we store the world edge y values

    [Header("Laser Properties")]
    [SerializeField] GameObject laserPrefab;
    [SerializeField] float laserSpeed;

    void Start()
    {
        // Assign the main camera if not set
        if (cam == null)
        {
            cam = Camera.main;

            if (cam == null)
            {
                Debug.LogError("[Player] No Camera assigned and no MainCamera found.");
                enabled = false; // Disable script so that we dont spam errors or run broken logic
                return;
            }
        }

        CalculateScreenBounds();
    }


    void Update()
    {
        HandleMovement();
        HandleFiring();
    }

    private void CalculateScreenBounds()
    {
        Vector3 leftEdge = cam.ViewportToWorldPoint(new Vector3(0f, 0.5f, 0f));
        Vector3 rightEdge = cam.ViewportToWorldPoint(new Vector3(1f, 0.5f, 0f));
        Vector3 topEdge = cam.ViewportToWorldPoint(new Vector3(0.5f, 1f, 0f));
        Vector3 bottomEdge = cam.ViewportToWorldPoint(new Vector3(0.5f, 0f, 0f));

        minX = leftEdge.x + horizontalPadding;
        maxX = rightEdge.x - horizontalPadding;
        minY = bottomEdge.y + verticalPadding;
        maxY = topEdge.y - verticalPadding;

        // Cleaner Log Messages - you can use $"Message text goes here {Variable1} and {Variable2)" in Debug.Log
        Debug.Log($"The screen bounds are minX: {minX}, maxX: {maxX}, minY: {minY} ,maxY: {maxY}");
    }

    private void HandleMovement()
    {
        // Read input axes
        float moveX = Input.GetAxis("Horizontal");
        float moveY = Input.GetAxis("Vertical");

        // 2D movement vector
        Vector3 movement = new Vector3(moveX, moveY, 0f) * moveSpeed * Time.deltaTime;

        // Proposed new position
        Vector3 newPos = transform.position + movement;

        // Clamp X and Y
        newPos.x = Mathf.Clamp(newPos.x, minX, maxX);
        newPos.y = Mathf.Clamp(newPos.y, minY, maxY);

        // Preserve current Z (important even in 2D)
        newPos.z = transform.position.z;

        // Apply
        transform.position = newPos;
    }

    private void HandleFiring()
    {
        // Fire one laser when "Fire1" is pressed (mouse or controller)
        if (Input.GetButtonDown("Fire1"))
        {
            if (laserPrefab == null)
            {
                Debug.LogWarning("Player: No laserPrefab assigned.");
                return;
            }

            // Spawn the laser at the player's position
            GameObject laserInstance = Instantiate(laserPrefab, transform.position, Quaternion.identity);

            // Apply velocity if it has a Rigidbody2D
            Rigidbody2D rb = laserInstance.GetComponent<Rigidbody2D>();
            if (rb != null)
            {
                rb.velocity = new Vector2(0f, laserSpeed);
            }
        }

    }

}



        </code></pre>
          <code>LaserProjectile.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;

public class LaserProjectile : MonoBehaviour
{
    // When this object is no longer visible by any camera,
    // Unity calls this automatically.
    private void OnBecameInvisible()
    {
        // Clean up the projectile so it doesn't live forever off-screen
        Destroy(gameObject);
    }
}

          
        </code></pre>
</details>

        <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If your laser doesn‚Äôt move or even appear, double-check that the prefab has a <code>Rigidbody2D</code> with zero gravity and that you assigned the prefab reference in the Inspector.
        </blockquote>
      </article>

      <!-- CODE BLOCK 4 -->
      <article class="code-example" id="code-block-4">
        <div class="code-header">
          <div class="code-title">Code Block 4 ‚Äì <!-- Short description here -->Continuous Firing With a Coroutine</div>
          <div class="code-ref">Appendix #04</div>
        </div>
        <details>
<summary>üí° Hints (click to expand)</summary>
<code>Player.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;
using System.Collections;  // Needed for IEnumerator and coroutines

public class Player : MonoBehaviour
{
    [Header("Movement")] // Use headers to make variables pretty in the inspector
    public float moveSpeed = 8f;

    [Header("Screen Bounds")]
    public Camera cam; //The camera in our scene
    public float horizontalPadding = 0.55f; // How close can we get to the sides
    public float verticalPadding = 0.55f; // How close can we get to the sides
    private float minX, maxX; //Where we store the world edge x values
    private float minY, maxY; //Where we store the world edge y values

    [Header("Laser Properties")]
    [SerializeField] GameObject laserPrefab; //Laser To Spawn
    [SerializeField] float laserSpeed; // How fast the laser travels
    [SerializeField] float firingInterval = 0.2f; // Delay between shots while firing

    // Reference to the running coroutine (if any)
    private Coroutine firingCoroutine;


    void Start()
    {
        // Assign the main camera if not set
        if (cam == null)
        {
            cam = Camera.main;

            if (cam == null)
            {
                Debug.LogError("[Player] No Camera assigned and no MainCamera found.");
                enabled = false; // Disable script so that we dont spam errors or run broken logic
                return;
            }
        }

        CalculateScreenBounds();
    }


    void Update()
    {
        HandleMovement();
        HandleFiring();
    }

    private void CalculateScreenBounds()
    {
        Vector3 leftEdge = cam.ViewportToWorldPoint(new Vector3(0f, 0.5f, 0f));
        Vector3 rightEdge = cam.ViewportToWorldPoint(new Vector3(1f, 0.5f, 0f));
        Vector3 topEdge = cam.ViewportToWorldPoint(new Vector3(0.5f, 1f, 0f));
        Vector3 bottomEdge = cam.ViewportToWorldPoint(new Vector3(0.5f, 0f, 0f));

        minX = leftEdge.x + horizontalPadding;
        maxX = rightEdge.x - horizontalPadding;
        minY = bottomEdge.y + verticalPadding;
        maxY = topEdge.y - verticalPadding;

        // Cleaner Log Messages - you can use $"Message text goes here {Variable1} and {Variable2)" in Debug.Log
        Debug.Log($"The screen bounds are minX: {minX}, maxX: {maxX}, minY: {minY} ,maxY: {maxY}"); 
    }

    private void HandleMovement()
    {
        // Read input axes
        float moveX = Input.GetAxis("Horizontal");
        float moveY = Input.GetAxis("Vertical");

        // 2D movement vector
        Vector3 movement = new Vector3(moveX, moveY, 0f) * moveSpeed * Time.deltaTime;

        // Proposed new position
        Vector3 newPos = transform.position + movement;

        // Clamp X and Y
        newPos.x = Mathf.Clamp(newPos.x, minX, maxX);
        newPos.y = Mathf.Clamp(newPos.y, minY, maxY);

        // Preserve current Z (important even in 2D)
        newPos.z = transform.position.z;

        // Apply
        transform.position = newPos;
    }

    private void HandleFiring()
    {
        // Start firing when Fire1 is pressed
        if (Input.GetButtonDown("Fire1"))
        {
            if (firingCoroutine == null)
            {
                firingCoroutine = StartCoroutine(FireContinuously());
            }
        }

        // Stop firing when Fire1 is released
        if (Input.GetButtonUp("Fire1"))
        {
            if (firingCoroutine != null)
            {
                StopCoroutine(firingCoroutine);
                firingCoroutine = null;
            }
        }
    }

    private IEnumerator FireContinuously()
    {
        // Loop forever until stopped from outside
        while (true)
        {
            if (laserPrefab != null)
            {
                // Spawn a laser at the player's position
                GameObject laserInstance = Instantiate(
                    laserPrefab,
                    transform.position,
                    Quaternion.identity
                );

                // Give the laser upward velocity
                Rigidbody2D rb = laserInstance.GetComponent<Rigidbody2D>();
                if (rb != null)
                {
                    rb.velocity = new Vector2(0f, laserSpeed);
                }
            }
            else
            {
                Debug.LogWarning("Player: No laserPrefab assigned.");
            }

            // Wait for the firing interval before spawning the next shot
            yield return new WaitForSeconds(firingInterval);
        }
    }

}


          </code></pre>
</details>
          <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If the firing speed seems wrong or never stops, make sure you're only starting the coroutine once and stopping it correctly when the button is released.
        </blockquote>
      </article>

      <!-- CODE BLOCK 5 -->
      <article class="code-example" id="code-block-5">
        <div class="code-header">
          <div class="code-title">Code Block 5 ‚Äì <!-- Short description here -->Enemy Waypoints Setup & Debug</div>
          <div class="code-ref">Appendix #05</div>
        </div>
        <details>
<summary>üí° Hints (click to expand)</summary>
<code>EnemyPathing.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EnemyPathfinding : MonoBehaviour
{
    [Header("Pathfinding")]
    [SerializeField] Transform pathRoot;
    public List<Transform> waypoints;

    // Start is called before the first frame update
    void Start()
    {
        InitializePathfinding();
        transform.position = waypoints[0].position;
    }

    private void Update()
    {
        
    }

    private void InitializePathfinding()
    {
        // Safety check ‚Äì make sure a path has been assigned
        if (pathRoot == null)
        {
            Debug.LogWarning("EnemyPathing: No pathRoot assigned on " + gameObject.name);
            return;
        }

        // Populate the waypoints list from all children of pathRoot
        foreach (Transform child in pathRoot)
        {
            // Each child under pathRoot is treated as one waypoint
            waypoints.Add(child);
        }

        // Log each waypoint so we can check the order in the Console
        for (int i = 0; i < waypoints.Count; i++)
        {
            Transform wp = waypoints[i];
            Debug.Log(
                $"Waypoint {i} -> {wp.name} at position {wp.position}",
                this
            );
        }
    }

    // Visualize the waypoints to sanity check they are in the right place - we can essentially copy the for loop here, but use it inside OnDrawGizmos
    private void OnDrawGizmos()
    {
        if (waypoints == null) return;

        for (int i = 0; i < waypoints.Count; i++)
        {
            Transform wp = waypoints[i];
            if (wp == null) continue;

            // Give each gizmo a consistent colour based on index
            Gizmos.color = Color.HSVToRGB((i / (float)waypoints.Count), 1f, 1f);

            // Draw the waypoint position
            Gizmos.DrawWireSphere(wp.position, 0.2f);
        }
    }
}


        </code></pre>
</details>

          <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If no waypoints print to the Console, confirm that the <code>pathRoot</code> object is assigned and that the waypoint transforms are children of it in the correct order.
        </blockquote>
      </article>

      <!-- CODE BLOCK 6 -->
      <article class="code-example" id="code-block-6">
        <div class="code-header">
          <div class="code-title">Code Block 6 ‚Äì <!-- Short description here -->Moving the Enemy With MoveTowards</div>
          <div class="code-ref">Appendix #06</div>
        </div>
        <details>
<summary>üí° Hints (click to expand)</summary>
<code>EnemyPathing.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class EnemyPathfinding : MonoBehaviour
{
    [Header("Pathfinding")]
    [SerializeField] Transform pathRoot;
    public List<Transform> waypoints;

    [Header("Enemy Movement")]
// Movement speed along the path
    public float moveSpeed = 3f;

    // Index of the current waypoint we are moving towards
    private int currentIndex = 0;

    // How close is "close enough" to consider a waypoint reached
    public float arriveThreshold = 0.1f;


    // Start is called before the first frame update
    void Start()
    {
        InitializePathfinding();
        transform.position = waypoints[0].position;
    }

    private void Update()
    {
        // Only move if we have waypoints to follow
        if (waypoints.Count == 0) return;

        FollowPath();
    }

    

    private void InitializePathfinding()
    {
        // Safety check ‚Äì make sure a path has been assigned
        if (pathRoot == null)
        {
            Debug.LogWarning("EnemyPathing: No pathRoot assigned on " + gameObject.name);
            return;
        }

        // Populate the waypoints list from all children of pathRoot
        foreach (Transform child in pathRoot)
        {
            // Each child under pathRoot is treated as one waypoint
            waypoints.Add(child);
        }

        // Log each waypoint so we can check the order in the Console
        for (int i = 0; i < waypoints.Count; i++)
        {
            Transform wp = waypoints[i];
            Debug.Log(
                $"Waypoint {i} -> {wp.name} at position {wp.position}",
                this
            );
        }
    }

    // Visualize the waypoints to sanity check they are in the right place - we can essentially copy the for loop here, but use it inside OnDrawGizmos
    private void OnDrawGizmos()
    {
        if (waypoints == null) return;

        for (int i = 0; i < waypoints.Count; i++)
        {
            Transform wp = waypoints[i];
            if (wp == null) continue;

            // Give each gizmo a consistent colour based on index
            Gizmos.color = Color.HSVToRGB((i / (float)waypoints.Count), 1f, 1f);

            // Draw the waypoint position
            Gizmos.DrawWireSphere(wp.position, 0.2f);
        }
    }

    private void FollowPath()
    {
        // If we've already passed the last waypoint, destroy the enemy
        if (currentIndex >= waypoints.Count)
        {
            Destroy(gameObject);
            return;
        }

        // Get the current target waypoint
        Transform targetWaypoint = waypoints[currentIndex];

        // Move towards the target waypoint at a steady speed
        transform.position = Vector3.MoveTowards(
            transform.position,
            targetWaypoint.position,
            moveSpeed * Time.deltaTime
        );

        // Check how far we are from the target
        float distanceToTarget = Vector3.Distance(transform.position, targetWaypoint.position);

        // If close enough, move on to the next waypoint
        if (distanceToTarget < arriveThreshold)
        {
            currentIndex++;

            // If that was the last waypoint, the object will be cleaned up next frame
        }
    }
}


        </code></pre>
</details>
          <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If the enemy jumps or stops early, check that its starting position is set to the first waypoint and that the distance threshold allows it to reliably ‚Äúarrive‚Äù before advancing.
        </blockquote>
      </article>
          

    </section>

    <!-- DOWNLOADS -->
    <section class="lecture-section">
      <h2>Downloads</h2>
      <div class="resource-links">
        <!-- Update links/paths as appropriate -->
        <a class="resource-pill" href="https://github.com/robblofield/GDD422---Prototypes-and-Programming-Principles/tree/main/labs">
          üß™ Lab Files
        </a>
        <a class="resource-pill" href="https://github.com/robblofield/Unity-Project-Startup-Files">
          üì¶ Unity Project Startup Files
        </a>
      </div>
    </section>

  </main>

</body>
</html>

